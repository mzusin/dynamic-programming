/*
https://github.com/mzusin/dynamic-programming
MIT License      
Copyright (c) 2023-present, Miriam Zusin       
*/
var m=r=>{let e=new Map,t=n=>{if(n<=1)return n;if(e.has(n))return e.get(n);let o=t(n-1)+t(n-2);return e.set(n,o),o};return t(r)},b=r=>{let e=[0,1];if(r<=1)return r;for(let t=2;t<=r;t++)e.push(e[t-1]+e[t-2]);return e[e.length-1]},f=r=>{let e=[0,1,1];for(let t=3;t<=r;t++)e[t]=e[t-1]+e[t-2]+e[t-3];return e[r]},l=r=>{var t;let e=[];for(let n=0;n<=r;n++){let o=n>>1,u=n&1;e[n]=((t=e[o])!=null?t:0)+u}return e},a=r=>{let e=[],t=u=>{if(u>=r.length)return 0;if(e[u]!==void 0)return e[u];let i=t(u+1),s=t(u+2),c=r[u]+Math.min(i,s);return e[u]=c,c},n=t(0),o=t(1);return Math.min(n,o)},h=r=>{let e=[0,0];for(let t=2;t<=r.length;t++)e[t]=Math.min(r[t-1]+e[t-1],r[t-2]+e[t-2]);return e[r.length]},p=r=>{if(r<=0)return[1];if(r===1)return[1,1];let e=(t,n)=>{if(n>r)return t;let o=[1];for(let u=1;u<n;u++)o[u]=t[u-1]+t[u];return o.push(1),e(o,n+1)};return e([1,1],2)},g=r=>{if(r<=0)return[1];if(r===1)return[1,1];let e=[1];for(let t=0;t<r;t++){let n=[1];for(let o=1;o<e.length;o++)n[o]=e[o-1]+e[o];n.push(1),e=n}return e},v=r=>{let e=r[0],t=0;for(let n=1;n<r.length;n++){let o=r[n];if(o<=e)e=o;else{let u=o-e;t=Math.max(t,u)}}return t};export{l as countBits,b as fibonacciNumberIterative,m as fibonacciNumberRecursive,g as getRowIterative,p as getRowRecursive,v as maxProfit,h as minCostClimbingStairsIterative,a as minCostClimbingStairsRecursive,f as tribonacciIterative};
